name: CI

on:
  pull_request_target:
    branches:
      - main
      - develop
  workflow_dispatch:

jobs:
  integrated-checks:
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'workflow_dispatch') ||
      (github.event.pull_request.user.login == 'ukwhatn') ||
      (github.event.pull_request.user.login == 'dependabot[bot]')
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.ref }}

      # Setup & Dependency Installation
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Cache poetry dependencies
        uses: actions/cache@v4
        id: poetry-cache
        with:
          path: ~/.cache/pypoetry
          key: ${{ runner.os }}-poetry-${{ hashFiles('**/poetry.lock') }}

      - name: Install dependencies
        id: install
        run: |
          python -m pip install --upgrade pip
          pip install poetry
          poetry config virtualenvs.create false
          poetry install --with dev,discord,db,dumper

      - name: Setup environment
        run: |
          make envs:setup

          # ç½®æ›å¯¾è±¡ã®è¨­å®šã‚’ãƒ«ãƒ¼ãƒ—å‡¦ç†ç”¨ã®é…åˆ—ã¨ã—ã¦å®šç¾©
          declare -A replacements=(
            ["envs/discord.env:BOT_TOKEN=\"\""]="BOT_TOKEN=\"\${{ secrets.CIBOT_TOKEN }}\""
            ["envs/aws-s3.env:S3_ACCESS_KEY=your_access_key"]="S3_ACCESS_KEY=\"\${{ secrets.S3_ACCESS_KEY }}\""
            ["envs/aws-s3.env:S3_SECRET_KEY=your_secret_key"]="S3_SECRET_KEY=\"\${{ secrets.S3_SECRET_KEY }}\""
          )

          # å„ç½®æ›ã‚’ãƒ«ãƒ¼ãƒ—ã§å®Ÿè¡Œ
          for pattern in "${!replacements[@]}"; do
            IFS=':' read -r file search_pattern <<< "$pattern"
            replace_value="${replacements[$pattern]}"
            description="${search_pattern%%=*}"  # ã€Œ=ã€ã‚ˆã‚Šå‰ã®éƒ¨åˆ†ã‚’æŠ½å‡º

            # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä½œæˆ
            cp "$file" "$file.bak"

            # ç½®æ›ã‚’å®Ÿè¡Œ
            sed -i "s|$search_pattern|$replace_value|" "$file"

            # å·®åˆ†ã‚’ãƒã‚§ãƒƒã‚¯
            if ! diff -q "$file.bak" "$file" > /dev/null; then
              echo "${description}ã®ç½®æ›ãŒæˆåŠŸã—ã¾ã—ãŸ"
            else
              echo "${description}ã®ç½®æ›ãŒè¡Œã‚ã‚Œã¾ã›ã‚“ã§ã—ãŸ"
              exit 1
            fi
          done

      # Quality and Security Checks (Run in parallel for speed)
      - name: Run Quality and Security Checks
        run: |
          echo "Running linting and security checks..."
          make lint &
          LINT_PID=$!
          
          # Bandit scan for critical issues only
          echo "Running critical Bandit scan..."
          poetry run bandit -r app/ -x tests/,app/db/dump.py -ll &
          BANDIT_PID=$!
          
          # Semgrep scan for critical issues only
          echo "Running critical Semgrep scan..."
          poetry run semgrep scan --config=p/python --config=p/security-audit --config=p/owasp-top-ten --severity ERROR --error &
          SEMGREP_PID=$!
          
          # Install and run Trivy
          echo "Installing Trivy Scanner..."
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin v0.46.1
          
          echo "Scanning Dockerfiles..."
          trivy config --exit-code 1 --severity CRITICAL ./docker/app.Dockerfile &
          TRIVY1_PID=$!
          
          trivy config --exit-code 1 --severity CRITICAL ./docker/db-tools.Dockerfile &
          TRIVY2_PID=$!
          
          # Wait for all processes to complete, fail if any fail
          wait $LINT_PID || { echo "Linting failed"; exit 1; }
          wait $BANDIT_PID || { echo "Bandit scan failed"; exit 1; }
          wait $SEMGREP_PID || { echo "Semgrep scan failed"; exit 1; }
          wait $TRIVY1_PID || { echo "Trivy app.Dockerfile scan failed"; exit 1; }
          wait $TRIVY2_PID || { echo "Trivy db-tools.Dockerfile scan failed"; exit 1; }
          
          echo "All quality and security checks passed!"

      # Docker Build and Health Check
      - name: Build Docker images
        run: |
          make build ENV=test

      - name: Start services
        run: make up ENV=test

      - name: Health check with timeout
        run: |
          timeout=30
          interval=5
          elapsed=0
          
          while [ $elapsed -lt $timeout ]; do
            if ! make ps ENV=test | grep -qiE "(starting|restarting|unhealthy)"; then
              echo "âœ… ã™ã¹ã¦ã®ã‚µãƒ¼ãƒ“ã‚¹ãŒæ­£å¸¸ã«èµ·å‹•ã—ã¾ã—ãŸï¼"
              break
            fi
          
            echo "ğŸ•’ ã‚µãƒ¼ãƒ“ã‚¹èµ·å‹•ä¸­... çµŒéæ™‚é–“: ${elapsed}ç§’/${timeout}ç§’"
            sleep $interval
            elapsed=$((elapsed + interval))
          done
          
          if [ $elapsed -ge $timeout ]; then
            echo "âŒ ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: ã‚µãƒ¼ãƒ“ã‚¹ãŒèµ·å‹•ã—ã¾ã›ã‚“ã§ã—ãŸ"
            make logs:once ENV=test
            exit 1
          fi
          
          if make ps ENV=test | grep -q "unhealthy"; then
            echo "âŒ ä¸å¥å…¨ãªã‚µãƒ¼ãƒ“ã‚¹ãŒã‚ã‚Šã¾ã™:"
            make ps ENV=test
            make logs:once ENV=test
            exit 1
          fi
          
          make ps ENV=test

      - name: Check Dumper service
        run: |
          make db:dump:test ENV=test

      - name: Clean up
        if: always()
        run: make down ENV=test